From: Christian Borntraeger <borntraeger@de.ibm.com>
Date: Fri, 12 Jan 2018 17:34:47 +0100
Subject: s390x/kvm: Handle bpb feature
Commit-Id: 4646696f7996c039f847f54540f0a8f7fa170cc4

We need to handle the bpb control on reset and migration. Normally
stfle.82 is transparent (and the normal guest part works without
hypervisor activity). To prevent any issues we require full
host kernel support for this feature.

Cc: qemu-stable@nongnu.org
Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
Message-Id: <20180118085628.40798-3-borntraeger@de.ibm.com>
Reviewed-by: Thomas Huth <thuth@redhat.com>
Reviewed-by: David Hildenbrand <david@redhat.com>
[CH: 'Branch Prediction Blocking' -> 'Branch prediction blocking']
Signed-off-by: Cornelia Huck <cohuck@redhat.com>
(cherry-picked from b073c87517d4d348c7bac0f0b35e8e83e6354d82)
---
 target-s390x/cpu.c              |  1 +
 target-s390x/cpu.h              |  1 +
 target-s390x/cpu_features.c     |  1 +
 target-s390x/cpu_features_def.h |  1 +
 target-s390x/gen-features.c     |  1 +
 target-s390x/kvm.c              | 14 ++++++++++++++
 target-s390x/machine.c          | 17 +++++++++++++++++
 7 files changed, 36 insertions(+)

diff --git a/target-s390x/cpu.c b/target-s390x/cpu.c
index 0a39d31237..d8d1805b71 100644
--- a/target-s390x/cpu.c
+++ b/target-s390x/cpu.c
@@ -79,6 +79,7 @@ static void s390_cpu_reset(CPUState *s)
     CPUS390XState *env = &cpu->env;
 
     env->pfault_token = -1UL;
+    env->bpbc = false;
     scc->parent_reset(s);
     cpu->env.sigp_order = 0;
     s390_cpu_set_state(CPU_STATE_STOPPED, cpu);
diff --git a/target-s390x/cpu.h b/target-s390x/cpu.h
index fd36a25cf5..792eb04d39 100644
--- a/target-s390x/cpu.h
+++ b/target-s390x/cpu.h
@@ -91,6 +91,7 @@ typedef struct CPUS390XState {
 
     uint32_t fpc;          /* floating-point control register */
     uint32_t cc_op;
+    bool bpbc;             /* branch prediction blocking */
 
     float_status fpu_status; /* passed to softfloat lib */
 
diff --git a/target-s390x/cpu_features.c b/target-s390x/cpu_features.c
index 42fd9d792b..69c9b45f14 100644
--- a/target-s390x/cpu_features.c
+++ b/target-s390x/cpu_features.c
@@ -81,6 +81,7 @@ static const S390FeatDef s390_features[] = {
     FEAT_INIT("msa4-base", S390_FEAT_TYPE_STFL, 77, "Message-security-assist-extension-4 facility (excluding subfunctions)"),
     FEAT_INIT("edat2", S390_FEAT_TYPE_STFL, 78, "Enhanced-DAT facility 2"),
     FEAT_INIT("dfppc", S390_FEAT_TYPE_STFL, 80, "Decimal-floating-point packed-conversion facility"),
+    FEAT_INIT("bpb", S390_FEAT_TYPE_STFL, 82, "Branch prediction blocking"),
     FEAT_INIT("vx", S390_FEAT_TYPE_STFL, 129, "Vector facility"),
 
     FEAT_INIT("gsls", S390_FEAT_TYPE_SCLP_CONF_CHAR, 40, "SIE: Guest-storage-limit-suppression facility"),
diff --git a/target-s390x/cpu_features_def.h b/target-s390x/cpu_features_def.h
index aa5ab8d371..2a96fa7235 100644
--- a/target-s390x/cpu_features_def.h
+++ b/target-s390x/cpu_features_def.h
@@ -71,6 +71,7 @@ typedef enum {
     S390_FEAT_MSA_EXT_4,
     S390_FEAT_EDAT_2,
     S390_FEAT_DFP_PACKED_CONVERSION,
+    S390_FEAT_BPB,
     S390_FEAT_VECTOR,
     S390_FEAT_SIE_GSLS,
     S390_FEAT_ESOP,
diff --git a/target-s390x/gen-features.c b/target-s390x/gen-features.c
index e674738ae3..eec302830d 100644
--- a/target-s390x/gen-features.c
+++ b/target-s390x/gen-features.c
@@ -288,6 +288,7 @@ static uint16_t base_GEN13_GA1[] = {
 
 /* full features differing to the base in order of release */
 static uint16_t full_GEN7_GA1[] = {
+    S390_FEAT_BPB,
     S390_FEAT_SIE_F2,
     S390_FEAT_SIE_SKEY,
     S390_FEAT_SIE_GPERE,
diff --git a/target-s390x/kvm.c b/target-s390x/kvm.c
index 5fc4ed1bbd..3210337a51 100644
--- a/target-s390x/kvm.c
+++ b/target-s390x/kvm.c
@@ -451,6 +451,11 @@ int kvm_arch_put_registers(CPUState *cs, int level)
         }
     }
 
+    if (can_sync_regs(cs, KVM_SYNC_BPBC)) {
+        cs->kvm_run->s.regs.bpbc = env->bpbc;
+        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_BPBC;
+    }
+
     /* Finally the prefix */
     if (can_sync_regs(cs, KVM_SYNC_PREFIX)) {
         cs->kvm_run->s.regs.prefix = env->psa;
@@ -557,6 +562,10 @@ int kvm_arch_get_registers(CPUState *cs)
         memcpy(env->riccb, cs->kvm_run->s.regs.riccb, 64);
     }
 
+    if (can_sync_regs(cs, KVM_SYNC_BPBC)) {
+        env->bpbc = cs->kvm_run->s.regs.bpbc;
+    }
+
     /* pfault parameters */
     if (can_sync_regs(cs, KVM_SYNC_PFAULT)) {
         env->pfault_token = cs->kvm_run->s.regs.pft;
@@ -2577,6 +2586,11 @@ void kvm_s390_get_host_cpu_model(S390CPUModel *model, Error **errp)
         set_bit(S390_FEAT_CMM, model->features);
     }
 
+    /* bpb needs kernel support for migration, VSIE and reset */
+    if (!kvm_check_extension(kvm_state, KVM_CAP_S390_BPB)) {
+        clear_bit(S390_FEAT_BPB, model->features);
+    }
+
     if (s390_known_cpu_type(cpu_type)) {
         /* we want the exact model, even if some features are missing */
         model->def = s390_find_cpu_def(cpu_type, ibc_gen(unblocked_ibc),
diff --git a/target-s390x/machine.c b/target-s390x/machine.c
index edc3a4717b..aa526dc5ce 100644
--- a/target-s390x/machine.c
+++ b/target-s390x/machine.c
@@ -156,6 +156,22 @@ const VMStateDescription vmstate_riccb = {
     }
 };
 
+static bool bpbc_needed(void *opaque)
+{
+    return s390_has_feat(S390_FEAT_BPB);
+}
+
+const VMStateDescription vmstate_bpbc = {
+    .name = "cpu/bpbc",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .needed = bpbc_needed,
+    .fields = (VMStateField[]) {
+        VMSTATE_BOOL(env.bpbc, S390CPU),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
 const VMStateDescription vmstate_s390_cpu = {
     .name = "cpu",
     .post_load = cpu_post_load,
@@ -188,6 +204,7 @@ const VMStateDescription vmstate_s390_cpu = {
         &vmstate_fpu,
         &vmstate_vregs,
         &vmstate_riccb,
+        &vmstate_bpbc,
         NULL
     },
 };
-- 
2.11.0

